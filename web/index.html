<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIN FRAMEWORK - Coming Soon! / إطار عمل CIN - قريباًّ</title>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,0..200" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="./assets/css/style.css">
</head>
<body>
    <div id="loadingScreen">
        <div class="cin-loading-spinner"></div>
        <p class="cin-text-lead" data-translate="loading_message">Loading CIN Framework...</p>
    </div>
    <header class="cin-header cin-fade-in">
        <a href="https://www.cin-framework.com">
        <img src="./assets/img/cin/CIN.svg" alt="Logo CIN" width="40" height="40"></a>
        <div class="cin-language-toggle">
            <button class="cin-lang-btn active" onclick="setLanguage('en')">EN</button>
            <button class="cin-lang-btn" onclick="setLanguage('ar')">AR</button>
        </div>
    </header>
    <div id="content-wrapper" class="content-wrapper">
        <div class="content-inner">

        <!-- Hero Badge Component -->
            <div class="cin-hero-badge">
                <span data-translate="🚀 إطار العمل في التطوير">🚀 Framework in Development</span>
            </div>

            <!-- Main Heading Component -->
            <h1 class="cin-heading-1" data-translate="!قريباً">Coming Soon!</h1>
            
            <!-- Lead Text Component -->
            <p class="cin-text-lead cin-mb-8" data-translate="سيتم إطلاق CIN Framework رسمياً في 2025-10-01">
                The CIN Framework will be officially launched on 2025-10-01.
            </p>
            
            <!-- Framework Logo Display -->
            <div class="cin-heading-3 cin-mb-4">CIN Framework</div>
            <p class="cin-tagline">
                CIN FRAMEWORK – WEB 4 – POWERED BY LOCAL SELF-SUFFICIENCY AND AGGRESSIVE SECURITY
            </p>
            
            <!-- Email Subscription Component -->
            <div class="cin-subscription">
                <h3 class="cin-heading-5 cin-text-center cin-mb-8" data-translate="استعد — CIN FRAMEWORK قادم قريبًا!">
                    Get ready — CIN FRAMEWORK is coming soon!
                </h3>
                <form class="cin-input-group cin-max-w-md cin-mx-auto" onsubmit="handleEmailSubmit(event)">
                    <input 
                        type="email" 
                        class="cin-input" 
                        data-translate-placeholder="أدخل بريدك الإلكتروني"
                        placeholder="Enter your email address" 
                        required
                    >
                    <button type="submit" class="cin-btn cin-btn-primary" data-translate="أخبرني عند الإطلاق">
                        Notify me when it launches.
                    </button>
                </form>
                <!-- Custom message box for subscription -->
                <div id="subscriptionMessage" style="display: none; margin-top: var(--cin-space-4);" class="cin-alert cin-alert-info"></div>
            </div>

            <!-- Info Alert Component -->
            <div class="cin-alert cin-alert-info">
                <strong data-translate="حالة التطوير:">Development status:</strong>
                <span data-translate="CIN Framework قيد التطوير النشط. انضم إلى قائمتنا البريدية لتكون أول من يعلم عند الإطلاق!">
                    The CIN Framework is under active development. Join our mailing list to be the first to know when it launches!
                </span>
            </div>

        </div>
    </div>
    <button class="cin-btn-fab" onclick="scrollToTop()" title="Scroll to top">
        <span class="material-symbols-rounded">keyboard_double_arrow_up</span>
    </button>
    <script src="./assets/js/script.js"></script>
    <!-- js water -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Water.js"></script>
    <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>
    <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>
    <script>
        window.onload = function() {
            // إعداد المشهد، الكاميرا، والمُقدّم (renderer)
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // تحديد موضع الكاميرا الأولي
            camera.position.z = 130;
            camera.position.y = 5;

            // الضباب والإضاءة
            scene.background = new THREE.Color(0x000c1c);
            scene.fog = new THREE.Fog(0x000c1c, 100, 800);
            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 100;
            scene.add(sunLight);
            const sun = new THREE.Mesh(
                new THREE.SphereGeometry(20, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xfff0c0, emissive: 0xfff0c0 })
            );
            scene.add(sun);
            const sunGlowLight = new THREE.PointLight(0xfff0c0, 5000, 200);
            scene.add(sunGlowLight);
            const moonLight = new THREE.PointLight(0xf0f0ff, 0.5, 300);
            scene.add(moonLight);
            const moonTextureLoader = new THREE.TextureLoader();
            const moonTexture = moonTextureLoader.load('./assets/img/3D/earth_clouds_1024.png');
            const moon = new THREE.Mesh(
                new THREE.SphereGeometry(10, 32, 32),
                new THREE.MeshStandardMaterial({
                    map: moonTexture,
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5
                })
            );
            scene.add(moon);
            
            // الماء وقاع المحيط
            const waterGeometry = new THREE.PlaneGeometry(2000, 2000);
            const water = new THREE.Water(
                waterGeometry,
                {
                    textureWidth: 1024,
                    textureHeight: 1024,
                    waterNormals: new THREE.TextureLoader().load('./assets/img/3D/waternormals.jpg', function(texture) {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(10, 10);
                    }),
                    alpha: 1.0,
                    sunDirection: sunLight.position.clone().normalize(),
                    sunColor: 0xffffff,
                    waterColor: 0x000510,
                    distortionScale: 3.7,
                    fog: scene.fog !== undefined,
                    side: THREE.DoubleSide
                }
            );
            water.rotation.x = -Math.PI / 2;
            water.position.y = -5;
            scene.add(water);
            
            // قعر المحيط من الحجارة مع تكسشر
            const oceanFloorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            const stoneTextureLoader = new THREE.TextureLoader();
            const stoneTexture = stoneTextureLoader.load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==');
            
            // إنشاء تكسشر حجري بسيط
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // رسم نمط حجري
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 20 + 5;
                const gray = Math.floor(Math.random() * 100 + 50);
                ctx.fillStyle = `rgb(${gray}, ${gray - 10}, ${gray - 20})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const stoneCanvasTexture = new THREE.CanvasTexture(canvas);
            stoneCanvasTexture.wrapS = stoneCanvasTexture.wrapT = THREE.RepeatWrapping;
            stoneCanvasTexture.repeat.set(20, 20);
            
            const oceanFloorMaterial = new THREE.MeshStandardMaterial({
                map: stoneCanvasTexture,
                color: 0x2a2a2a,
                metalness: 0.1,
                roughness: 0.9,
                normalScale: new THREE.Vector2(2, 2)
            });
            
            // إضافة تضاريس للقعر
            const positions = oceanFloorGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i);
                const height = Math.sin(x * 0.01) * Math.cos(z * 0.01) * 10 + Math.random() * 5;
                positions.setY(i, height);
            }
            positions.needsUpdate = true;
            oceanFloorGeometry.computeVertexNormals();
            
            const oceanFloor = new THREE.Mesh(oceanFloorGeometry, oceanFloorMaterial);
            oceanFloor.rotation.x = -Math.PI / 2;
            oceanFloor.position.y = -200;
            oceanFloor.receiveShadow = true;
            scene.add(oceanFloor);
            
            // الحشرات المضيئة في أعماق البحر
            const glowingBugs = [];
            const bugCount = 30;
            
            for (let i = 0; i < bugCount; i++) {
                // جسم الحشرة
                const bugGeometry = new THREE.SphereGeometry(0.5, 8, 6);
                const bugMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.1, 1, 0.8),
                    emissive: new THREE.Color().setHSL(Math.random() * 0.3 + 0.1, 1, 0.5),
                    transparent: true,
                    opacity: 0.8
                });
                
                const bug = new THREE.Mesh(bugGeometry, bugMaterial);
                
                // موضع عشوائي في أعماق البحر
                bug.position.set(
                    (Math.random() - 0.5) * 400,
                    -20 - Math.random() * 150,
                    (Math.random() - 0.5) * 400
                );
                
                // إضافة ضوء للحشرة
                const bugLight = new THREE.PointLight(
                    bugMaterial.color.getHex(),
                    2,
                    20
                );
                bugLight.position.copy(bug.position);
                scene.add(bugLight);
                
                // خصائص الحركة العشوائية
                bug.userData = {
                    light: bugLight,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.1
                    ),
                    originalY: bug.position.y,
                    time: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.02 + 0.01
                };
                
                glowingBugs.push(bug);
                scene.add(bug);
            }

            // النجوم فقط
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 20000;
            const starPositions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount * 3; i += 3) {
                starPositions[i] = (Math.random() - 0.5) * 800;
                starPositions[i + 1] = Math.random() * 800;
                starPositions[i + 2] = (Math.random() - 0.5) * 800;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);

            // إنشاء النص ثلاثي الأبعاد
            let mainTextMesh;
            let loadedFont;
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                loadedFont = font;
                const geometry = new THREE.TextGeometry('CIN FRAMEWORK', {
                    font: loadedFont,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.5,
                    bevelSize: 0.5,
                    bevelOffset: 0,
                    bevelSegments: 5
                });
                geometry.center();
                const material = new THREE.MeshPhongMaterial({
                    color: 0x00aaff,
                    emissive: 0x0055ff,
                    specular: 0x00aaff
                });
                mainTextMesh = new THREE.Mesh(geometry, material);
                mainTextMesh.position.y = 20; // وضع النص فوق الماء
                scene.add(mainTextMesh);
            });
            
            // متغيرات حالة الغوص
            const contentWrapper = document.getElementById('content-wrapper');
        const contentInner = contentWrapper.querySelector('.content-inner');
            let isUnderwater = false;
            
            // حلقة الرسوم المتحركة
            const animate = function(time) {
                requestAnimationFrame(animate);
                const globalTime = Date.now() * 0.001;

                // تحديث لون النص ثلاثي الأبعاد وجعله يطفو
                if (mainTextMesh) {
                    const hue = (globalTime * 0.05) % 1;
                    mainTextMesh.material.color.setHSL(hue, 1, 0.5);
                    mainTextMesh.material.emissive.setHSL(hue, 1, 0.5);

                    // إضافة حركة طفو واقعية
                    mainTextMesh.position.y = 20 + Math.sin(globalTime) * 0.5;
                    mainTextMesh.rotation.y += 0.005;
                }
                
                // دورة الليل والنهار
                const orbitRadius = 400;
                const orbitSpeed = 0.1;
                const angle = (globalTime * orbitSpeed) % (Math.PI * 2);
                
                sun.position.x = Math.sin(angle) * orbitRadius;
                sun.position.y = Math.cos(angle) * orbitRadius;
                sun.position.z = Math.sin(angle) * 100;
                
                moon.position.x = -Math.sin(angle) * orbitRadius;
                moon.position.y = -Math.cos(angle) * orbitRadius;
                moon.position.z = -Math.sin(angle) * 100;

                const sunY = sun.position.y;
                sunLight.position.copy(sun.position);
                sunGlowLight.position.copy(sun.position);
                moonLight.position.copy(moon.position);

                let dayFactor = Math.max(0, sunY / orbitRadius);
                if (sunY < 0) {
                    dayFactor = 0;
                }

                sunLight.intensity = dayFactor * 20;
                sunGlowLight.intensity = dayFactor * 5000;
                moonLight.intensity = (1 - dayFactor) * 0.5;

                const dayColor = new THREE.Color(0x4682b4);
                const nightColor = new THREE.Color(0x000c1c);
                const lerpedColor = new THREE.Color();
                lerpedColor.copy(nightColor).lerp(dayColor, dayFactor);
                
                if (!isUnderwater) {
                    scene.background = lerpedColor;
                    scene.fog.color = lerpedColor;
                }
                
                starField.rotation.y += 0.001;
                starField.material.opacity = 1 - dayFactor;
                
                // تحريك الحشرات المضيئة
                glowingBugs.forEach(bug => {
                    bug.userData.time += bug.userData.speed;
                    
                    // حركة عشوائية مع تذبذب
                    bug.position.add(bug.userData.velocity);
                    bug.position.y = bug.userData.originalY + Math.sin(bug.userData.time) * 5;
                    
                    // تغيير الاتجاه عشوائياً
                    if (Math.random() < 0.02) {
                        bug.userData.velocity.set(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.1
                        );
                    }
                    
                    // إعادة تموضع عند الخروج من الحدود
                    if (bug.position.x > 200) bug.position.x = -200;
                    if (bug.position.x < -200) bug.position.x = 200;
                    if (bug.position.z > 200) bug.position.z = -200;
                    if (bug.position.z < -200) bug.position.z = 200;
                    if (bug.position.y > -10) bug.position.y = -170;
                    if (bug.position.y < -180) bug.position.y = -20;
                    
                    // تحديث موضع الضوء
                    bug.userData.light.position.copy(bug.position);
                    
                    // تأثير وميض للضوء
                    const flicker = 0.8 + Math.sin(bug.userData.time * 3) * 0.2;
                    bug.userData.light.intensity = 2 * flicker;
                    bug.material.opacity = 0.6 + flicker * 0.2;
                });
                
                water.material.uniforms[ 'time' ].value += 1.0 / 60.0;
                water.material.uniforms.sunDirection.value.copy(sunLight.position).normalize();
                
                renderer.render(scene, camera);
            };

            // وظيفة موحدة للتعامل مع التمرير واللمس
            const scrollSpeed = 0.1;
            function handleScroll(deltaY) {
                camera.position.y -= deltaY * scrollSpeed;
                camera.position.y = Math.min(5, Math.max(-100, camera.position.y));

                // تم حذف كود إظهار الكروت بناءً على العمق - العناصر تظهر مباشرة

                // الانتقال إلى وضع تحت الماء مع تأثير الغوص التدريجي
                const belowWater = camera.position.y < -5;
                const divingProgress = Math.max(0, Math.min(1, (-camera.position.y + 5) / 10)); // تقدم الغوص من 0 إلى 1
                
                if (belowWater !== isUnderwater) {
                    isUnderwater = belowWater;
                    if (isUnderwater) {
                        scene.background.set(0x000005);
                        scene.fog.color.set(0x000005);
                        ambientLight.intensity = 0.5;
                        water.material.uniforms.distortionScale.value = 8;
                        sun.visible = false;
                        moon.visible = false;
                        sunLight.intensity = 0;
                        sunGlowLight.intensity = 0;
                        moonLight.intensity = 0;
                        if (mainTextMesh) mainTextMesh.visible = false;
                        contentWrapper.style.display = 'flex';
                        
                        // تطبيق تأثير الغوص التدريجي على العناصر
                        const cards = contentWrapper.querySelectorAll('.underwater-card');
                        cards.forEach((card, index) => {
                            card.style.transform = `translateY(${100 - (divingProgress * 100)}px)`;
                            card.style.opacity = divingProgress;
                            card.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
                        });
                    } else {
                        const dayColor = new THREE.Color(0x4682b4);
                        const nightColor = new THREE.Color(0x000c1c);
                        const lerpedColor = new THREE.Color();
                        const dayFactor = Math.max(0, sun.position.y / 400);
                        lerpedColor.copy(nightColor).lerp(dayColor, dayFactor);
                        
                        scene.background.set(lerpedColor);
                        scene.fog.color.set(lerpedColor);
                        ambientLight.intensity = 5;
                        water.material.uniforms.distortionScale.value = 3.7;
                        sun.visible = true;
                        moon.visible = true;
                        sunLight.intensity = dayFactor * 20;
                        sunGlowLight.intensity = dayFactor * 5000;
                        moonLight.intensity = (1 - dayFactor) * 0.5;
                        if (mainTextMesh) mainTextMesh.visible = true;
                        contentWrapper.style.display = 'none';
                    }
                }
                
                // تحديث تأثير الغوص أثناء الحركة
                if (isUnderwater) {
                    const cards = contentWrapper.querySelectorAll('.underwater-card');
                    cards.forEach((card, index) => {
                        const cardDepth = -15 - (index * 20); // عمق كل كارت
                        const cardProgress = Math.max(0, Math.min(1, (-camera.position.y - cardDepth + 10) / 15));
                        
                        card.style.transform = `translateY(${50 - (cardProgress * 50)}px)`;
                        card.style.opacity = cardProgress;
                    });
                }
            }

            // التحكم في الكاميرا والغوص باستخدام عجلة الماوس
            window.addEventListener('wheel', (event) => {
                handleScroll(event.deltaY);
            });
            
            // متغيرات التحكم باللمس
            let startY = 0;

            // التحكم باللمس لأجهزة الهاتف
            window.addEventListener('touchstart', (event) => {
                startY = event.touches[0].clientY;
            });

            window.addEventListener('touchmove', (event) => {
                // منع التمرير الافتراضي للمتصفح
                event.preventDefault();
                const deltaY = startY - event.touches[0].clientY;
                handleScroll(deltaY);
                startY = event.touches[0].clientY;
            }, { passive: false }); // { passive: false } لإتاحة استخدام preventDefault()
            
            // إضافة دعم التمرير باللمس المحسن للعنصر content-wrapper
            let touchStartY = 0;
            let lastTouchY = 0;
            let touchVelocity = 0;
            let isScrolling = false;
            let animationId = null;
            
            contentInner.addEventListener('touchstart', (event) => {
                touchStartY = event.touches[0].clientY;
                lastTouchY = touchStartY;
                touchVelocity = 0;
                isScrolling = true;
                
                // إيقاف أي تحريك سابق
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }, { passive: true });
            
            contentInner.addEventListener('touchmove', (event) => {
                if (isScrolling) {
                    const touchCurrentY = event.touches[0].clientY;
                    const deltaY = lastTouchY - touchCurrentY;
                    
                    // حساب السرعة للحصول على تمرير أكثر سلاسة
                    touchVelocity = deltaY * 2.5; // زيادة الحساسية
                    
                    // التمرير داخل العنصر مع تطبيق السرعة
                    contentInner.scrollTop += touchVelocity;
                    lastTouchY = touchCurrentY;
                }
            }, { passive: true });
            
            contentInner.addEventListener('touchend', () => {
                isScrolling = false;
                
                // إضافة تأثير الاستمرارية (momentum) بعد رفع الإصبع
                if (Math.abs(touchVelocity) > 5) {
                    const momentum = () => {
                        touchVelocity *= 0.95; // تقليل السرعة تدريجياً
                        contentInner.scrollTop += touchVelocity;
                        
                        if (Math.abs(touchVelocity) > 1) {
                            animationId = requestAnimationFrame(momentum);
                        } else {
                            animationId = null;
                        }
                    };
                    animationId = requestAnimationFrame(momentum);
                }
            }, { passive: true });
            
            // معالجة تغيير حجم النافذة
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate(performance.now());
        };

        // Email subscription handler
        function handleEmailSubmit(event) {
            event.preventDefault();
            const email = event.target.querySelector('input[type="email"]').value;
            const messageBox = document.getElementById('subscriptionMessage');
            
            // Simple email validation
            if (email && email.includes('@')) {
                messageBox.innerHTML = '<strong>شكراً لك!</strong> تم تسجيل بريدك الإلكتروني بنجاح. سنتواصل معك عند إطلاق CIN Framework.';
                messageBox.className = 'cin-alert cin-alert-success';
                messageBox.style.display = 'block';
                event.target.reset();
            } else {
                messageBox.innerHTML = '<strong>خطأ:</strong> يرجى إدخال بريد إلكتروني صحيح.';
                messageBox.className = 'cin-alert cin-alert-error';
                messageBox.style.display = 'block';
            }
            
            // Hide message after 5 seconds
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        }
    </script>
</body>
</html>
