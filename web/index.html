<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CIN FRAMEWORK - Coming Soon! / Ø¥Ø·Ø§Ø± Ø¹Ù…Ù„ CIN - Ù‚Ø±ÙŠØ¨Ø§Ù‘Ù‹</title>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,0..200" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="./assets/css/style.css">
</head>
<body>
    <div id="loadingScreen">
        <div class="cin-loading-spinner"></div>
        <p class="cin-text-lead" data-translate="loading_message">Loading CIN Framework...</p>
    </div>
    <header class="cin-header cin-fade-in">
        <a href="https://www.cin-framework.com">
        <img src="./assets/img/cin/CIN.svg" alt="Logo CIN" width="40" height="40"></a>
        <div class="cin-language-toggle">
            <button class="cin-lang-btn active" onclick="setLanguage('en')">EN</button>
            <button class="cin-lang-btn" onclick="setLanguage('ar')">AR</button>
        </div>
    </header>
    <div id="content-wrapper" class="content-wrapper">
        <div class="content-inner">

        <!-- Hero Badge Component -->
            <div class="cin-hero-badge">
                <span data-translate="ğŸš€ Ø¥Ø·Ø§Ø± Ø§Ù„Ø¹Ù…Ù„ ÙÙŠ Ø§Ù„ØªØ·ÙˆÙŠØ±">ğŸš€ Framework in Development</span>
            </div>

            <!-- Main Heading Component -->
            <h1 class="cin-heading-1" data-translate="!Ù‚Ø±ÙŠØ¨Ø§Ù‹">Coming Soon!</h1>
            
            <!-- Lead Text Component -->
            <p class="cin-text-lead cin-mb-8" data-translate="Ø³ÙŠØªÙ… Ø¥Ø·Ù„Ø§Ù‚ CIN Framework Ø±Ø³Ù…ÙŠØ§Ù‹ ÙÙŠ 2025-10-01">
                The CIN Framework will be officially launched on 2025-10-01.
            </p>
            
            <!-- Framework Logo Display -->
            <div class="cin-heading-3 cin-mb-4">CIN Framework</div>
            <p class="cin-tagline">
                CIN FRAMEWORK â€“ WEB 4 â€“ POWERED BY LOCAL SELF-SUFFICIENCY AND AGGRESSIVE SECURITY
            </p>
            
            <!-- Email Subscription Component -->
            <div class="cin-subscription">
                <h3 class="cin-heading-5 cin-text-center cin-mb-8" data-translate="Ø§Ø³ØªØ¹Ø¯ â€” CIN FRAMEWORK Ù‚Ø§Ø¯Ù… Ù‚Ø±ÙŠØ¨Ù‹Ø§!">
                    Get ready â€” CIN FRAMEWORK is coming soon!
                </h3>
                <form class="cin-input-group cin-max-w-md cin-mx-auto" onsubmit="handleEmailSubmit(event)">
                    <input 
                        type="email" 
                        class="cin-input" 
                        data-translate-placeholder="Ø£Ø¯Ø®Ù„ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ"
                        placeholder="Enter your email address" 
                        required
                    >
                    <button type="submit" class="cin-btn cin-btn-primary" data-translate="Ø£Ø®Ø¨Ø±Ù†ÙŠ Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚">
                        Notify me when it launches.
                    </button>
                </form>
                <!-- Custom message box for subscription -->
                <div id="subscriptionMessage" style="display: none; margin-top: var(--cin-space-4);" class="cin-alert cin-alert-info"></div>
            </div>

            <!-- Info Alert Component -->
            <div class="cin-alert cin-alert-info">
                <strong data-translate="Ø­Ø§Ù„Ø© Ø§Ù„ØªØ·ÙˆÙŠØ±:">Development status:</strong>
                <span data-translate="CIN Framework Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ù†Ø´Ø·. Ø§Ù†Ø¶Ù… Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…ØªÙ†Ø§ Ø§Ù„Ø¨Ø±ÙŠØ¯ÙŠØ© Ù„ØªÙƒÙˆÙ† Ø£ÙˆÙ„ Ù…Ù† ÙŠØ¹Ù„Ù… Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚!">
                    The CIN Framework is under active development. Join our mailing list to be the first to know when it launches!
                </span>
            </div>

        </div>
    </div>
    <button class="cin-btn-fab" onclick="scrollToTop()" title="Scroll to top">
        <span class="material-symbols-rounded">keyboard_double_arrow_up</span>
    </button>
    <script src="./assets/js/script.js"></script>
    <!-- js water -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Water.js"></script>
    <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>
    <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>
    <script>
        window.onload = function() {
            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ØŒ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ØŒ ÙˆØ§Ù„Ù…ÙÙ‚Ø¯Ù‘Ù… (renderer)
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø£ÙˆÙ„ÙŠ
            camera.position.z = 130;
            camera.position.y = 5;

            // Ø§Ù„Ø¶Ø¨Ø§Ø¨ ÙˆØ§Ù„Ø¥Ø¶Ø§Ø¡Ø©
            scene.background = new THREE.Color(0x000c1c);
            scene.fog = new THREE.Fog(0x000c1c, 100, 800);
            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 1;
            sunLight.shadow.camera.far = 100;
            scene.add(sunLight);
            const sun = new THREE.Mesh(
                new THREE.SphereGeometry(20, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xfff0c0, emissive: 0xfff0c0 })
            );
            scene.add(sun);
            const sunGlowLight = new THREE.PointLight(0xfff0c0, 5000, 200);
            scene.add(sunGlowLight);
            const moonLight = new THREE.PointLight(0xf0f0ff, 0.5, 300);
            scene.add(moonLight);
            const moonTextureLoader = new THREE.TextureLoader();
            const moonTexture = moonTextureLoader.load('./assets/img/3D/earth_clouds_1024.png');
            const moon = new THREE.Mesh(
                new THREE.SphereGeometry(10, 32, 32),
                new THREE.MeshStandardMaterial({
                    map: moonTexture,
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5
                })
            );
            scene.add(moon);
            
            // Ø§Ù„Ù…Ø§Ø¡ ÙˆÙ‚Ø§Ø¹ Ø§Ù„Ù…Ø­ÙŠØ·
            const waterGeometry = new THREE.PlaneGeometry(2000, 2000);
            const water = new THREE.Water(
                waterGeometry,
                {
                    textureWidth: 1024,
                    textureHeight: 1024,
                    waterNormals: new THREE.TextureLoader().load('./assets/img/3D/waternormals.jpg', function(texture) {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(10, 10);
                    }),
                    alpha: 1.0,
                    sunDirection: sunLight.position.clone().normalize(),
                    sunColor: 0xffffff,
                    waterColor: 0x000510,
                    distortionScale: 3.7,
                    fog: scene.fog !== undefined,
                    side: THREE.DoubleSide
                }
            );
            water.rotation.x = -Math.PI / 2;
            water.position.y = -5;
            scene.add(water);
            
            // Ù‚Ø¹Ø± Ø§Ù„Ù…Ø­ÙŠØ· Ù…Ù† Ø§Ù„Ø­Ø¬Ø§Ø±Ø© Ù…Ø¹ ØªÙƒØ³Ø´Ø±
            const oceanFloorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            const stoneTextureLoader = new THREE.TextureLoader();
            const stoneTexture = stoneTextureLoader.load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==');
            
            // Ø¥Ù†Ø´Ø§Ø¡ ØªÙƒØ³Ø´Ø± Ø­Ø¬Ø±ÙŠ Ø¨Ø³ÙŠØ·
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Ø±Ø³Ù… Ù†Ù…Ø· Ø­Ø¬Ø±ÙŠ
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 20 + 5;
                const gray = Math.floor(Math.random() * 100 + 50);
                ctx.fillStyle = `rgb(${gray}, ${gray - 10}, ${gray - 20})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const stoneCanvasTexture = new THREE.CanvasTexture(canvas);
            stoneCanvasTexture.wrapS = stoneCanvasTexture.wrapT = THREE.RepeatWrapping;
            stoneCanvasTexture.repeat.set(20, 20);
            
            const oceanFloorMaterial = new THREE.MeshStandardMaterial({
                map: stoneCanvasTexture,
                color: 0x2a2a2a,
                metalness: 0.1,
                roughness: 0.9,
                normalScale: new THREE.Vector2(2, 2)
            });
            
            // Ø¥Ø¶Ø§ÙØ© ØªØ¶Ø§Ø±ÙŠØ³ Ù„Ù„Ù‚Ø¹Ø±
            const positions = oceanFloorGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i);
                const height = Math.sin(x * 0.01) * Math.cos(z * 0.01) * 10 + Math.random() * 5;
                positions.setY(i, height);
            }
            positions.needsUpdate = true;
            oceanFloorGeometry.computeVertexNormals();
            
            const oceanFloor = new THREE.Mesh(oceanFloorGeometry, oceanFloorMaterial);
            oceanFloor.rotation.x = -Math.PI / 2;
            oceanFloor.position.y = -200;
            oceanFloor.receiveShadow = true;
            scene.add(oceanFloor);
            
            // Ø§Ù„Ø­Ø´Ø±Ø§Øª Ø§Ù„Ù…Ø¶ÙŠØ¦Ø© ÙÙŠ Ø£Ø¹Ù…Ø§Ù‚ Ø§Ù„Ø¨Ø­Ø±
            const glowingBugs = [];
            const bugCount = 30;
            
            for (let i = 0; i < bugCount; i++) {
                // Ø¬Ø³Ù… Ø§Ù„Ø­Ø´Ø±Ø©
                const bugGeometry = new THREE.SphereGeometry(0.5, 8, 6);
                const bugMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.1, 1, 0.8),
                    emissive: new THREE.Color().setHSL(Math.random() * 0.3 + 0.1, 1, 0.5),
                    transparent: true,
                    opacity: 0.8
                });
                
                const bug = new THREE.Mesh(bugGeometry, bugMaterial);
                
                // Ù…ÙˆØ¶Ø¹ Ø¹Ø´ÙˆØ§Ø¦ÙŠ ÙÙŠ Ø£Ø¹Ù…Ø§Ù‚ Ø§Ù„Ø¨Ø­Ø±
                bug.position.set(
                    (Math.random() - 0.5) * 400,
                    -20 - Math.random() * 150,
                    (Math.random() - 0.5) * 400
                );
                
                // Ø¥Ø¶Ø§ÙØ© Ø¶ÙˆØ¡ Ù„Ù„Ø­Ø´Ø±Ø©
                const bugLight = new THREE.PointLight(
                    bugMaterial.color.getHex(),
                    2,
                    20
                );
                bugLight.position.copy(bug.position);
                scene.add(bugLight);
                
                // Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
                bug.userData = {
                    light: bugLight,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.1
                    ),
                    originalY: bug.position.y,
                    time: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.02 + 0.01
                };
                
                glowingBugs.push(bug);
                scene.add(bug);
            }

            // Ø§Ù„Ù†Ø¬ÙˆÙ… ÙÙ‚Ø·
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 20000;
            const starPositions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount * 3; i += 3) {
                starPositions[i] = (Math.random() - 0.5) * 800;
                starPositions[i + 1] = Math.random() * 800;
                starPositions[i + 2] = (Math.random() - 0.5) * 800;
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Øµ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
            let mainTextMesh;
            let loadedFont;
            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
                loadedFont = font;
                const geometry = new THREE.TextGeometry('CIN FRAMEWORK', {
                    font: loadedFont,
                    size: 8,
                    height: 1,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.5,
                    bevelSize: 0.5,
                    bevelOffset: 0,
                    bevelSegments: 5
                });
                geometry.center();
                const material = new THREE.MeshPhongMaterial({
                    color: 0x00aaff,
                    emissive: 0x0055ff,
                    specular: 0x00aaff
                });
                mainTextMesh = new THREE.Mesh(geometry, material);
                mainTextMesh.position.y = 20; // ÙˆØ¶Ø¹ Ø§Ù„Ù†Øµ ÙÙˆÙ‚ Ø§Ù„Ù…Ø§Ø¡
                scene.add(mainTextMesh);
            });
            
            // Ù…ØªØºÙŠØ±Ø§Øª Ø­Ø§Ù„Ø© Ø§Ù„ØºÙˆØµ
            const contentWrapper = document.getElementById('content-wrapper');
        const contentInner = contentWrapper.querySelector('.content-inner');
            let isUnderwater = false;
            
            // Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
            const animate = function(time) {
                requestAnimationFrame(animate);
                const globalTime = Date.now() * 0.001;

                // ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ù†Øµ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ÙˆØ¬Ø¹Ù„Ù‡ ÙŠØ·ÙÙˆ
                if (mainTextMesh) {
                    const hue = (globalTime * 0.05) % 1;
                    mainTextMesh.material.color.setHSL(hue, 1, 0.5);
                    mainTextMesh.material.emissive.setHSL(hue, 1, 0.5);

                    // Ø¥Ø¶Ø§ÙØ© Ø­Ø±ÙƒØ© Ø·ÙÙˆ ÙˆØ§Ù‚Ø¹ÙŠØ©
                    mainTextMesh.position.y = 20 + Math.sin(globalTime) * 0.5;
                    mainTextMesh.rotation.y += 0.005;
                }
                
                // Ø¯ÙˆØ±Ø© Ø§Ù„Ù„ÙŠÙ„ ÙˆØ§Ù„Ù†Ù‡Ø§Ø±
                const orbitRadius = 400;
                const orbitSpeed = 0.1;
                const angle = (globalTime * orbitSpeed) % (Math.PI * 2);
                
                sun.position.x = Math.sin(angle) * orbitRadius;
                sun.position.y = Math.cos(angle) * orbitRadius;
                sun.position.z = Math.sin(angle) * 100;
                
                moon.position.x = -Math.sin(angle) * orbitRadius;
                moon.position.y = -Math.cos(angle) * orbitRadius;
                moon.position.z = -Math.sin(angle) * 100;

                const sunY = sun.position.y;
                sunLight.position.copy(sun.position);
                sunGlowLight.position.copy(sun.position);
                moonLight.position.copy(moon.position);

                let dayFactor = Math.max(0, sunY / orbitRadius);
                if (sunY < 0) {
                    dayFactor = 0;
                }

                sunLight.intensity = dayFactor * 20;
                sunGlowLight.intensity = dayFactor * 5000;
                moonLight.intensity = (1 - dayFactor) * 0.5;

                const dayColor = new THREE.Color(0x4682b4);
                const nightColor = new THREE.Color(0x000c1c);
                const lerpedColor = new THREE.Color();
                lerpedColor.copy(nightColor).lerp(dayColor, dayFactor);
                
                if (!isUnderwater) {
                    scene.background = lerpedColor;
                    scene.fog.color = lerpedColor;
                }
                
                starField.rotation.y += 0.001;
                starField.material.opacity = 1 - dayFactor;
                
                // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø­Ø´Ø±Ø§Øª Ø§Ù„Ù…Ø¶ÙŠØ¦Ø©
                glowingBugs.forEach(bug => {
                    bug.userData.time += bug.userData.speed;
                    
                    // Ø­Ø±ÙƒØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù…Ø¹ ØªØ°Ø¨Ø°Ø¨
                    bug.position.add(bug.userData.velocity);
                    bug.position.y = bug.userData.originalY + Math.sin(bug.userData.time) * 5;
                    
                    // ØªØºÙŠÙŠØ± Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹
                    if (Math.random() < 0.02) {
                        bug.userData.velocity.set(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.1
                        );
                    }
                    
                    // Ø¥Ø¹Ø§Ø¯Ø© ØªÙ…ÙˆØ¶Ø¹ Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø­Ø¯ÙˆØ¯
                    if (bug.position.x > 200) bug.position.x = -200;
                    if (bug.position.x < -200) bug.position.x = 200;
                    if (bug.position.z > 200) bug.position.z = -200;
                    if (bug.position.z < -200) bug.position.z = 200;
                    if (bug.position.y > -10) bug.position.y = -170;
                    if (bug.position.y < -180) bug.position.y = -20;
                    
                    // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø¶ÙˆØ¡
                    bug.userData.light.position.copy(bug.position);
                    
                    // ØªØ£Ø«ÙŠØ± ÙˆÙ…ÙŠØ¶ Ù„Ù„Ø¶ÙˆØ¡
                    const flicker = 0.8 + Math.sin(bug.userData.time * 3) * 0.2;
                    bug.userData.light.intensity = 2 * flicker;
                    bug.material.opacity = 0.6 + flicker * 0.2;
                });
                
                water.material.uniforms[ 'time' ].value += 1.0 / 60.0;
                water.material.uniforms.sunDirection.value.copy(sunLight.position).normalize();
                
                renderer.render(scene, camera);
            };

            // ÙˆØ¸ÙŠÙØ© Ù…ÙˆØ­Ø¯Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ØªÙ…Ø±ÙŠØ± ÙˆØ§Ù„Ù„Ù…Ø³
            const scrollSpeed = 0.1;
            function handleScroll(deltaY) {
                camera.position.y -= deltaY * scrollSpeed;
                camera.position.y = Math.min(5, Math.max(-100, camera.position.y));

                // ØªÙ… Ø­Ø°Ù ÙƒÙˆØ¯ Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ÙƒØ±ÙˆØª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù…Ù‚ - Ø§Ù„Ø¹Ù†Ø§ØµØ± ØªØ¸Ù‡Ø± Ù…Ø¨Ø§Ø´Ø±Ø©

                // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ ÙˆØ¶Ø¹ ØªØ­Øª Ø§Ù„Ù…Ø§Ø¡ Ù…Ø¹ ØªØ£Ø«ÙŠØ± Ø§Ù„ØºÙˆØµ Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠ
                const belowWater = camera.position.y < -5;
                const divingProgress = Math.max(0, Math.min(1, (-camera.position.y + 5) / 10)); // ØªÙ‚Ø¯Ù… Ø§Ù„ØºÙˆØµ Ù…Ù† 0 Ø¥Ù„Ù‰ 1
                
                if (belowWater !== isUnderwater) {
                    isUnderwater = belowWater;
                    if (isUnderwater) {
                        scene.background.set(0x000005);
                        scene.fog.color.set(0x000005);
                        ambientLight.intensity = 0.5;
                        water.material.uniforms.distortionScale.value = 8;
                        sun.visible = false;
                        moon.visible = false;
                        sunLight.intensity = 0;
                        sunGlowLight.intensity = 0;
                        moonLight.intensity = 0;
                        if (mainTextMesh) mainTextMesh.visible = false;
                        contentWrapper.style.display = 'flex';
                        
                        // ØªØ·Ø¨ÙŠÙ‚ ØªØ£Ø«ÙŠØ± Ø§Ù„ØºÙˆØµ Ø§Ù„ØªØ¯Ø±ÙŠØ¬ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†Ø§ØµØ±
                        const cards = contentWrapper.querySelectorAll('.underwater-card');
                        cards.forEach((card, index) => {
                            card.style.transform = `translateY(${100 - (divingProgress * 100)}px)`;
                            card.style.opacity = divingProgress;
                            card.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
                        });
                    } else {
                        const dayColor = new THREE.Color(0x4682b4);
                        const nightColor = new THREE.Color(0x000c1c);
                        const lerpedColor = new THREE.Color();
                        const dayFactor = Math.max(0, sun.position.y / 400);
                        lerpedColor.copy(nightColor).lerp(dayColor, dayFactor);
                        
                        scene.background.set(lerpedColor);
                        scene.fog.color.set(lerpedColor);
                        ambientLight.intensity = 5;
                        water.material.uniforms.distortionScale.value = 3.7;
                        sun.visible = true;
                        moon.visible = true;
                        sunLight.intensity = dayFactor * 20;
                        sunGlowLight.intensity = dayFactor * 5000;
                        moonLight.intensity = (1 - dayFactor) * 0.5;
                        if (mainTextMesh) mainTextMesh.visible = true;
                        contentWrapper.style.display = 'none';
                    }
                }
                
                // ØªØ­Ø¯ÙŠØ« ØªØ£Ø«ÙŠØ± Ø§Ù„ØºÙˆØµ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø±ÙƒØ©
                if (isUnderwater) {
                    const cards = contentWrapper.querySelectorAll('.underwater-card');
                    cards.forEach((card, index) => {
                        const cardDepth = -15 - (index * 20); // Ø¹Ù…Ù‚ ÙƒÙ„ ÙƒØ§Ø±Øª
                        const cardProgress = Math.max(0, Math.min(1, (-camera.position.y - cardDepth + 10) / 15));
                        
                        card.style.transform = `translateY(${50 - (cardProgress * 50)}px)`;
                        card.style.opacity = cardProgress;
                    });
                }
            }

            // Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ÙˆØ§Ù„ØºÙˆØµ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ø¬Ù„Ø© Ø§Ù„Ù…Ø§ÙˆØ³
            window.addEventListener('wheel', (event) => {
                handleScroll(event.deltaY);
            });
            
            // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
            let startY = 0;

            // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ Ù„Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„Ù‡Ø§ØªÙ
            window.addEventListener('touchstart', (event) => {
                startY = event.touches[0].clientY;
            });

            window.addEventListener('touchmove', (event) => {
                // Ù…Ù†Ø¹ Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„Ù„Ù…ØªØµÙØ­
                event.preventDefault();
                const deltaY = startY - event.touches[0].clientY;
                handleScroll(deltaY);
                startY = event.touches[0].clientY;
            }, { passive: false }); // { passive: false } Ù„Ø¥ØªØ§Ø­Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… preventDefault()
            
            // Ø¥Ø¶Ø§ÙØ© Ø¯Ø¹Ù… Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø¨Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ù…Ø­Ø³Ù† Ù„Ù„Ø¹Ù†ØµØ± content-wrapper
            let touchStartY = 0;
            let lastTouchY = 0;
            let touchVelocity = 0;
            let isScrolling = false;
            let animationId = null;
            
            contentInner.addEventListener('touchstart', (event) => {
                touchStartY = event.touches[0].clientY;
                lastTouchY = touchStartY;
                touchVelocity = 0;
                isScrolling = true;
                
                // Ø¥ÙŠÙ‚Ø§Ù Ø£ÙŠ ØªØ­Ø±ÙŠÙƒ Ø³Ø§Ø¨Ù‚
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }, { passive: true });
            
            contentInner.addEventListener('touchmove', (event) => {
                if (isScrolling) {
                    const touchCurrentY = event.touches[0].clientY;
                    const deltaY = lastTouchY - touchCurrentY;
                    
                    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø³Ø±Ø¹Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙ…Ø±ÙŠØ± Ø£ÙƒØ«Ø± Ø³Ù„Ø§Ø³Ø©
                    touchVelocity = deltaY * 2.5; // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø­Ø³Ø§Ø³ÙŠØ©
                    
                    // Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¹Ù†ØµØ± Ù…Ø¹ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø³Ø±Ø¹Ø©
                    contentInner.scrollTop += touchVelocity;
                    lastTouchY = touchCurrentY;
                }
            }, { passive: true });
            
            contentInner.addEventListener('touchend', () => {
                isScrolling = false;
                
                // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© (momentum) Ø¨Ø¹Ø¯ Ø±ÙØ¹ Ø§Ù„Ø¥ØµØ¨Ø¹
                if (Math.abs(touchVelocity) > 5) {
                    const momentum = () => {
                        touchVelocity *= 0.95; // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø³Ø±Ø¹Ø© ØªØ¯Ø±ÙŠØ¬ÙŠØ§Ù‹
                        contentInner.scrollTop += touchVelocity;
                        
                        if (Math.abs(touchVelocity) > 1) {
                            animationId = requestAnimationFrame(momentum);
                        } else {
                            animationId = null;
                        }
                    };
                    animationId = requestAnimationFrame(momentum);
                }
            }, { passive: true });
            
            // Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate(performance.now());
        };

        // Email subscription handler
        function handleEmailSubmit(event) {
            event.preventDefault();
            const email = event.target.querySelector('input[type="email"]').value;
            const messageBox = document.getElementById('subscriptionMessage');
            
            // Simple email validation
            if (email && email.includes('@')) {
                messageBox.innerHTML = '<strong>Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ!</strong> ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø¨Ù†Ø¬Ø§Ø­. Ø³Ù†ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ø¹Ù†Ø¯ Ø¥Ø·Ù„Ø§Ù‚ CIN Framework.';
                messageBox.className = 'cin-alert cin-alert-success';
                messageBox.style.display = 'block';
                event.target.reset();
            } else {
                messageBox.innerHTML = '<strong>Ø®Ø·Ø£:</strong> ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØµØ­ÙŠØ­.';
                messageBox.className = 'cin-alert cin-alert-error';
                messageBox.style.display = 'block';
            }
            
            // Hide message after 5 seconds
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        }
    </script>
</body>
</html>
