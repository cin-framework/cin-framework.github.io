<!DOCTYPE html><html lang="ar"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="shortcut icon" href="favicon.ico" type="image/x-icon"><meta name="description" content="CIN FRAMEWORK - SOON"><meta name="keywords" content="CIN, FRAMEWORK, SOON"><title>CIN FRAMEWORK - SOON</title><style>body{ margin: 0; overflow: hidden; background-color: #000c1c; font-family: sans-serif; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh} canvas{ display: block} .info-text{ position: absolute; top: 20px; left: 50%; transform: translateX(-50%); font-size: 1.5rem; color: #ffffff; text-shadow: 0 0 10px rgba(0, 0, 0, 0.5)} </style></head><body><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script><script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script><script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Water.js"></script><script>window.onload=function(){ const scene=new THREE.Scene(); const camera=new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000); const renderer=new THREE.WebGLRenderer({ antialias: true}); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement); scene.background=new THREE.Color(0x000c1c); scene.fog=new THREE.Fog(0x000c1c, 100, 800); const ambientLight=new THREE.AmbientLight(0x404040, 5); scene.add(ambientLight); const sunLight=new THREE.DirectionalLight(0xffffff, 1); sunLight.castShadow=true; sunLight.shadow.mapSize.width=2048; sunLight.shadow.mapSize.height=2048; sunLight.shadow.camera.near=1; sunLight.shadow.camera.far=100; scene.add(sunLight); const sun=new THREE.Mesh( new THREE.SphereGeometry(20, 32, 32), new THREE.MeshBasicMaterial({ color: 0xfff0c0, emissive: 0xfff0c0}) ); scene.add(sun); const moonLight=new THREE.PointLight(0xf0f0ff, 0.5, 300); scene.add(moonLight); const moonTextureLoader=new THREE.TextureLoader(); const moonTexture=moonTextureLoader.load('https://www.realtimerendering.com/erich/udacity/exercises/textures/planets/earth_clouds_1024.png'); const moon=new THREE.Mesh( new THREE.SphereGeometry(10, 32, 32), new THREE.MeshStandardMaterial({ map: moonTexture, color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5}) ); scene.add(moon); const sunGlowLight=new THREE.PointLight(0xfff0c0, 5000, 200); scene.add(sunGlowLight); const waterGeometry=new THREE.PlaneGeometry(2000, 2000); const water=new THREE.Water( waterGeometry,{ textureWidth: 1024, textureHeight: 1024, waterNormals: new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', function(texture){ texture.wrapS=texture.wrapT=THREE.RepeatWrapping; texture.repeat.set(10, 10)}), alpha: 1.0, sunDirection: sunLight.position.clone().normalize(), sunColor: 0xffffff, waterColor: 0x001e0f, distortionScale: 3.7, fog: scene.fog !==undefined, side: THREE.DoubleSide} ); water.rotation.x=-Math.PI / 2; water.position.y=-5; scene.add(water); const oceanFloorGeometry=new THREE.PlaneGeometry(2000, 2000); const oceanFloorMaterial=new THREE.MeshStandardMaterial({ color: 0x00000a, metalness: 0, roughness: 1}); const oceanFloor=new THREE.Mesh(oceanFloorGeometry, oceanFloorMaterial); oceanFloor.rotation.x=-Math.PI / 2; oceanFloor.position.y=-200; oceanFloor.receiveShadow=true; scene.add(oceanFloor); const cloudTexture=new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/cloud.png'); const cloudGeometry=new THREE.BufferGeometry(); const cloudCount=100; const cloudPositions=new Float32Array(cloudCount * 3); for (let i=0; i < cloudCount * 3; i +=3){ cloudPositions[i]=(Math.random() - 0.5) * 800; cloudPositions[i + 1]=100 + Math.random() * 50; cloudPositions[i + 2]=(Math.random() - 0.5) * 800} cloudGeometry.setAttribute('position', new THREE.BufferAttribute(cloudPositions, 3)); const cloudMaterial=new THREE.PointsMaterial({ size: 50, map: cloudTexture, transparent: true, blending: THREE.AdditiveBlending}); const clouds=new THREE.Points(cloudGeometry, cloudMaterial); scene.add(clouds); const starGeometry=new THREE.BufferGeometry(); const starCount=20000; const starPositions=new Float32Array(starCount * 3); for (let i=0; i < starCount * 3; i +=3){ starPositions[i]=(Math.random() - 0.5) * 800; starPositions[i + 1]=Math.random() * 800; starPositions[i + 2]=(Math.random() - 0.5) * 800} starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3)); const starMaterial=new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8}); const starField=new THREE.Points(starGeometry, starMaterial); scene.add(starField); let textMesh; let arabicTextMesh; let countdownGroup; function calculateCountdown(){ const targetDate=new Date('2025-10-01T12:00:00'); const now=new Date(); const diff=targetDate - now; if (diff <=0){ return{ days: 0, hours: 0, minutes: 0, seconds: 0, expired: true}} const days=Math.floor(diff / (1000 * 60 * 60 * 24)); const hours=Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)); const minutes=Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60)); const seconds=Math.floor((diff % (1000 * 60)) / 1000); return{ days, hours, minutes, seconds, expired: false}} const fontLoader=new THREE.FontLoader(); fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font){ const textGeometry=new THREE.TextGeometry('CIN FRAMEWORK - SOON',{ font: font, size: 6, height: 1, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelOffset: 0, bevelSegments: 5}); textGeometry.center(); const textMaterial=new THREE.MeshPhongMaterial({ color: 0x00aaff, emissive: 0x0055ff, specular: 0x00aaff}); textMesh=new THREE.Mesh(textGeometry, textMaterial); textMesh.castShadow=true; textMesh.position.y=-10; scene.add(textMesh); const arabicTextGeometry=new THREE.TextGeometry('CIN framework launching soon',{ font: font, size: 4, height: 0.8, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.15, bevelSize: 0.15, bevelOffset: 0, bevelSegments: 5}); arabicTextGeometry.center(); const arabicTextMaterial=new THREE.MeshPhongMaterial({ color: 0xff6600, emissive: 0xff3300, specular: 0xff6600}); arabicTextMesh=new THREE.Mesh(arabicTextGeometry, arabicTextMaterial); arabicTextMesh.castShadow=true; arabicTextMesh.position.y=5; scene.add(arabicTextMesh); countdownGroup=new THREE.Group(); scene.add(countdownGroup); function updateCountdown(){ while(countdownGroup.children.length >0){ countdownGroup.remove(countdownGroup.children[0])} const countdown=calculateCountdown(); if (countdown.expired){ const expiredGeometry=new THREE.TextGeometry('Times up!',{ font: font, size: 3, height: 0.5, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelOffset: 0, bevelSegments: 5}); expiredGeometry.center(); const expiredMaterial=new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0x660000, specular: 0xff0000}); const expiredMesh=new THREE.Mesh(expiredGeometry, expiredMaterial); expiredMesh.position.y=15; countdownGroup.add(expiredMesh)} else{ const elements=[{ value: countdown.days, label: 'day', position: -30},{ value: countdown.hours, label: 'hour', position: -10},{ value: countdown.minutes, label: 'minute', position: 10},{ value: countdown.seconds, label: 'second', position: 30} ]; elements.forEach((element, index)=>{ const numberGeometry=new THREE.TextGeometry(element.value.toString().padStart(2, '0'),{ font: font, size: 4, height: 1, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelOffset: 0, bevelSegments: 5}); numberGeometry.center(); const numberMaterial=new THREE.MeshPhongMaterial({ color: 0x00ff88, emissive: 0x004422, specular: 0x00ff88}); const numberMesh=new THREE.Mesh(numberGeometry, numberMaterial); numberMesh.position.set(element.position, 20, 0); numberMesh.castShadow=true; countdownGroup.add(numberMesh); const labelGeometry=new THREE.TextGeometry(element.label,{ font: font, size: 1.5, height: 0.3, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelOffset: 0, bevelSegments: 3}); labelGeometry.center(); const labelMaterial=new THREE.MeshPhongMaterial({ color: 0xaaaaaa, emissive: 0x333333, specular: 0xaaaaaa}); const labelMesh=new THREE.Mesh(labelGeometry, labelMaterial); labelMesh.position.set(element.position, 15, 0); labelMesh.castShadow=true; countdownGroup.add(labelMesh)})}} setInterval(updateCountdown, 1000); updateCountdown()}); camera.position.z=150; camera.position.y=5; const controls=new THREE.PointerLockControls(camera, document.body); document.body.addEventListener('click', function(){ controls.lock()}); const velocity=new THREE.Vector3(); let moveForward=false; let moveBackward=false; let moveLeft=false; let moveRight=false; let movementSpeed=40.0; document.addEventListener('keydown', (event)=>{ switch (event.code){ case 'ArrowUp': moveForward=true; break; case 'ArrowDown': moveBackward=true; break; case 'ArrowLeft': moveLeft=true; break; case 'ArrowRight': moveRight=true; break}}); document.addEventListener('keyup', (event)=>{ switch (event.code){ case 'ArrowUp': moveForward=false; break; case 'ArrowDown': moveBackward=false; break; case 'ArrowLeft': moveLeft=false; break; case 'ArrowRight': moveRight=false; break}}); document.addEventListener('wheel', (event)=>{ if (controls.isLocked){ if (event.deltaY >0){ movementSpeed=Math.max(10, movementSpeed - 5)} else if (event.deltaY < 0){ movementSpeed=Math.min(1000, movementSpeed + 5)}}}); let prevTime=performance.now(); let isUnderwater=false; const WORLD_BOUNDS=400; const animate=function(time){ requestAnimationFrame(animate); const delta=(time - prevTime) / 1000; velocity.x -=velocity.x * 10.0 * delta; velocity.z -=velocity.z * 10.0 * delta; if (moveForward) velocity.z -=movementSpeed * delta; if (moveBackward) velocity.z +=movementSpeed * delta; if (moveLeft) velocity.x -=movementSpeed * delta; if (moveRight) velocity.x +=movementSpeed * delta; controls.moveForward(-velocity.z * delta); controls.moveRight(velocity.x * delta); if (camera.position.x >WORLD_BOUNDS) camera.position.x=WORLD_BOUNDS; if (camera.position.x < -WORLD_BOUNDS) camera.position.x=-WORLD_BOUNDS; if (camera.position.z >WORLD_BOUNDS) camera.position.z=WORLD_BOUNDS; if (camera.position.z < -WORLD_BOUNDS) camera.position.z=-WORLD_BOUNDS; prevTime=time; const globalTime=Date.now() * 0.001; if (textMesh){ textMesh.position.y=-10 + Math.sin(globalTime * 0.5) * 1; const hue=(globalTime * 0.05) % 1; textMesh.material.color.setHSL(hue, 1, 0.5); textMesh.material.emissive.setHSL(hue, 1, 0.3)} if (arabicTextMesh){ arabicTextMesh.position.y=5 + Math.sin(globalTime * 0.3 + Math.PI) * 0.8; const hue=((globalTime * 0.08) + 0.1) % 1; arabicTextMesh.material.color.setHSL(hue, 1, 0.6); arabicTextMesh.material.emissive.setHSL(hue, 1, 0.4); arabicTextMesh.rotation.y=Math.sin(globalTime * 0.2) * 0.1} if (countdownGroup){ countdownGroup.position.y=25 + Math.sin(globalTime * 0.4) * 2; countdownGroup.rotation.y=Math.sin(globalTime * 0.15) * 0.05; countdownGroup.children.forEach((child, index)=>{ if (child.isMesh){ child.rotation.x=Math.sin(globalTime * 0.5 + index * 0.5) * 0.1; child.position.z=Math.sin(globalTime * 0.3 + index * 0.8) * 2}})} const orbitRadius=400; const orbitSpeed=0.1; const angle=(globalTime * orbitSpeed) % (Math.PI * 2); sun.position.x=Math.sin(angle) * orbitRadius; sun.position.y=Math.cos(angle) * orbitRadius; sun.position.z=Math.sin(angle) * 100; moon.position.x=-Math.sin(angle) * orbitRadius; moon.position.y=-Math.cos(angle) * orbitRadius; moon.position.z=-Math.sin(angle) * 100; const sunY=sun.position.y; sunLight.position.copy(sun.position); sunGlowLight.position.copy(sun.position); moonLight.position.copy(moon.position); let dayFactor=Math.max(0, sunY / orbitRadius); if (sunY < 0){ dayFactor=0} sunLight.intensity=dayFactor * 20; sunGlowLight.intensity=dayFactor * 5000; moonLight.intensity=(1 - dayFactor) * 0.5; const dawnColor=new THREE.Color(0xff8800); const dayColor=new THREE.Color(0x4682b4); const duskColor=new THREE.Color(0xaa3300); const nightColor=new THREE.Color(0x000c1c); const lerpedColor=new THREE.Color(); if (dayFactor >0.9){ lerpedColor.copy(dayColor)} else if (dayFactor >0.6){ lerpedColor.copy(duskColor).lerp(dayColor, (dayFactor - 0.6) / 0.3)} else if (dayFactor >0.1){ lerpedColor.copy(nightColor).lerp(duskColor, (dayFactor - 0.1) / 0.5)} else{ lerpedColor.copy(nightColor)} scene.background=lerpedColor; scene.fog.color=lerpedColor; if (camera.position.y < -5 && !isUnderwater){ isUnderwater=true; scene.background.set(0x000005); scene.fog.color.set(0x000005); ambientLight.intensity=0.5; water.material.uniforms.distortionScale.value=8; sun.visible=false; moon.visible=false; sunLight.intensity=0; sunGlowLight.intensity=0; moonLight.intensity=0} else if (camera.position.y >=-5 && isUnderwater){ isUnderwater=false; scene.background.set(lerpedColor); scene.fog.color.set(lerpedColor); ambientLight.intensity=5; water.material.uniforms.distortionScale.value=3.7; sun.visible=true; moon.visible=true; sunLight.intensity=dayFactor * 20; sunGlowLight.intensity=dayFactor * 5000; moonLight.intensity=(1 - dayFactor) * 0.5} starField.rotation.y +=0.001; starField.material.opacity=1 - dayFactor; clouds.material.opacity=dayFactor; clouds.rotation.y +=0.0005; water.material.uniforms[ 'time' ].value +=1.0 / 60.0; water.material.uniforms.sunDirection.value.copy(sunLight.position).normalize(); renderer.render(scene, camera)}; window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight)}); animate(performance.now())}; </script></body></html>